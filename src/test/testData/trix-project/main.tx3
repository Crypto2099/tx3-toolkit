// Comprehensive Tx3 fixture file exercising all syntax constructs.
// Used by `trix check` to validate upstream Tx3 compatibility.

/*
UTF-8 stress test (lexer must not crash on non-ASCII in comments):
 CJK: ä½ å¥½ä¸–ç•Œ ã“ã‚“ã«ã¡ã¯ í•œêµ­ì–´
 Emoji: ğŸš€ğŸ’°ğŸ”¥âœ…âŒğŸ‰ğŸ‘¾ğŸ¦€
 Box drawing: â”€ â”‚ â”Œ â” â”” â”˜ â”œ â”¤ â”¬ â”´ â”¼
 Accented: cafe, resume, naive, Zurcher Kantonalbank
 Cyrillic: ĞŸÑ€Ğ¸Ğ²ĞµÑ‚ Ğ¼Ğ¸Ñ€
 Arabic: Ù…Ø±Ø­Ø¨Ø§ Ø¨Ø§Ù„Ø¹Ø§Ù„Ù…
 Math symbols: âˆ‘ âˆ âˆ« âˆš âˆ â‰ˆ â‰  â‰¤ â‰¥ âˆˆ âˆ‰ âŠ‚ âŠƒ
 Currency: Â£ Â¥ â‚¬ â‚¹ â‚¿
 Dashes and quotes: â€” â€“ ' ' " " Â« Â»
*/

party Sender;
party Receiver;

policy TokenPolicy = 0xabcdef0123456789abcdef0123456789abcdef0123456789abcdef01;

type LegacyState {
    owner: Address,
    balance: Int,
}

type TransferInfo {
    from: Address,
    to: Address,
    amount: Int,
}

type Action {
    Increment {
        value: Int,
    },
    Decrement {
        value: Int,
    },
    Reset,
}

type Container {
    items: List<Int>,
    lookup: Map<Bytes, Int>,
}

env {
    treasury: Address,
    min_deposit: Int,
}

asset MyToken = 0xabcdef0123456789abcdef0123456789abcdef0123456789abcdef01."TOKEN";

tx simple_transfer(qty: Int) {
    input source {
        from: Sender,
        min_amount: Ada(qty),
    }
    output {
        to: Receiver,
        amount: Ada(qty),
    }
    output {
        to: Sender,
        amount: source - Ada(qty) - fees,
    }
}

tx complex_tx(qty: Int, deadline: Int) {
    input source {
        from: Sender,
        min_amount: Ada(qty),
    }
    output {
        to: Receiver,
        amount: Ada(qty),
        datum: TransferInfo {
            from: Sender,
            to: Receiver,
            amount: qty,
        },
    }
    validity {
        since_slot: 100,
        until_slot: deadline,
    }
    signers {
        Sender,
    }
}

tx with_datum_is() {
    input source {
        from: Sender,
        datum_is: TransferInfo,
    }
    output {
        to: Sender,
        amount: Ada(100),
    }
}

tx multi_input() {
    input* sources {
        from: Sender,
        min_amount: Ada(1000),
    }
    output {
        to: Receiver,
        amount: Ada(1000),
    }
}

tx expression_test(a: Int, b: Int) {
    locals {
        sum: a + b,
        diff: a - b,
    }
    output {
        to: Sender,
        amount: Ada(sum + diff),
    }
}

tx variant_test() {
    output {
        to: Sender,
        amount: Ada(100),
        datum: Action::Increment {
            value: 42,
        },
    }
}

tx record_literal_test() {
    output {
        to: Sender,
        amount: Ada(100),
        datum: TransferInfo {
            from: Sender,
            to: Receiver,
            amount: 100,
        },
    }
}

tx list_test() {
    locals {
        items: [1, 2, 3],
    }
    output {
        to: Sender,
        amount: Ada(1),
    }
}

tx property_access_test() {
    input source {
        from: Sender,
        datum_is: TransferInfo,
    }
    output {
        to: Sender,
        amount: Ada(source.amount),
        datum: TransferInfo {
            from: source.from,
            to: source.to,
            amount: source.amount,
        },
    }
}

tx list_index_test(items: List<Int>) {
    output {
        to: Sender,
        amount: Ada(items[0]),
        datum: Action::Increment {
            value: items[1],
        },
    }
}

tx generic_params(items: List<Int>, lookup: Map<Bytes, Int>) {
    output {
        to: Sender,
        amount: Ada(1),
    }
}
